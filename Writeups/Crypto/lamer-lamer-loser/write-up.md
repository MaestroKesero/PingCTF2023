# Write-up: lame-lame-loser

## Category: crypto

## Author P1T4G0R45

```python
import Crypto
import numpy as np
from Crypto.Cipher import AES
from hashlib import sha256
from math import gcd
from Crypto.Util.Padding import pad

x = -74337111560408261770627327061677963299443114676921962193623077431929781105956693046458392735870264364007813650987534298743547687856228598375660321312737669922256322002836807209358272704779543549572555337507638951640423224736617988565507790110400638507902597678361464029732843617458061469432050977431403357467
y = 80004460393622006505206154227738652408980554199718416840470313398850884843675954680175518476630032820510826586724696390191570583297462980502959681243903214031598679172479920755464717427554287271300097926852452366085494286842499533040579721141160507448286612025375713562688645031383081188938949474253051185921
ct = b'\x9e\xae\\|\x80\xe9\x0br\xa9\xc1o8\x08\xdcy\xbf\x94\x97\x85\xdc\xbf\x94\xe2\xd7\x82\x8f\x81>\xf2\x1fl@+\x85\xe6\xd2}N\xcb\x12Ak\xfb\xc1\xbf\x88\'i</"\xf5\x01+4\x1aF\xb6\xf6\xdce!L\x9a'

# The code utilizes the LLL (Lenstra–Lenstra–Lovász lattice basis reduction algorithm) to reduce the basis vector in lattice theory, facilitating the solution of the Diophantine equation. In this specific case, the LLL algorithm is applied to find a short vector in the lattice generated by the matrix M. As 'a' and 'b' are used as coefficients in the equation, we scale them by 'H' (in this case, H = 2^2048) to achieve better lattice quality and shorter vectors.

H = 2**2048
M = matrix(ZZ,[
    [x,1,0],
    [y,0,1],
])
M[:,0] *= H

# The resulting vector 'r' is obtained by applying LLL and scaling.
r = M.LLL()[0]

# r = (0, 151695612364380967150062151434361439522173994270671377111811542602813501132418267696622963094839163651954533053084612363264523292942738976421507937641498637005503682414004225358769604640448059475475716273659000967029555627522368316498240533888547546289624436060801965906018046639760971486284863946026546928567, 133783396460824908452905922643710821124996646437207857242997480043083043845487576611357152531061915448057852148118836915231386180354362144960176027315451857763047821260426824385785023026207789496555473300628935818593918010782530870778283478363174752601385234330156752642482540727146234586552300932655431731711)

# AES is used in CBC mode to decrypt the ciphertext 'ct', and the AES key is generated based on the concatenation of 'a' and 'b', secured by the SHA-256 hash function.
aes = AES.new(sha256(f'{a}||{b}'.encode()).digest(), AES.MODE_CBC, iv=bytes(16))
ct = aes.decrypt(ct)
print(f'{ct = }')
# ct = b'ping{135str4_135str4_107v4sz_41g0r1thm_r0cks_sc41ing}\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b'

# The code benefits from LLL and scaling to efficiently find a solution to the Diophantine equation. The AES decryption part adds an additional layer of complexity to the task, enhancing its cryptographic nature.


Despite the title and what the flag said, you don't need to use LLL for this challenge. Simply using this will do the trick.
```
a = y // gcd(x,y) 
b = x // gcd(x,y)
```

```
